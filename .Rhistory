equal_no_spots[j,1:length(equal)] <- equal
}
rownames(equal_no_spots)<-as.character(non_zero[,1])
equal_no_spots<-unique(equal_no_spots)
#--------------------------------------------------------------------
# Go through the groups one by one. For each group the same number
#  of indices as spots where these genes are expressed are first
#  sampled. For each random sample, the counts in each bin, defined
#  above, are saved as the rows of counts_matrix_rand, and this is
#  repeated n times (here, n=1000), until the matrix has been filled.
#  Column-wise means of this matrix gives the mean distribution,
#  mean_counts. The differences between each individual random
#  distribution and the mean distribution are saved in diff_matr_rand.
#  The L1 norms of these differences are saved in L1_norms_rand.
#  The genes are then taken one by one. First, the indices of the
#  non-zero elements are obtained, i.e. the spots where the gene in
#  question is expressed. This is used to obtain the distances, which
#  are saved in eukl. The difference between the distribution of
#  these distances (in the same bins as the random distributions)
#  and the mean distance are calculated, the L1 norm is calculated
#  (L1_norm_real), and the p-value is calculated as
#  p=(no random samples with L1>L1(true sample))/(total no random
#  samples). If the numerator is equal to 0, it can however only
#  be said that p<1/n. These cases are currently saved as p=1/(10n).
#  In the supplementary material to the paper by Rodriques et al.
#  (Science 363, 1463â€“1467, 2019. doi 10.1126/science.aaw1219)
#  it is stated that p=(no random samples with L1<L1(true sample))/
#  (total no random samples), but this contradicts their
#  argumentation, as well as the example in figure S10.
#--------------------------------------------------------------------
for (i in 1:nrow(equal_no_spots)){
# The counts for the genes in question
values <- testdata[na.omit(equal_no_spots[i,]),]
# The number of distances required
len <- 0
for (l in 1:(as.numeric(rownames(equal_no_spots)[i])-1)){
len <- len + l
}
# The random distributions
eukl_for_rand <- vector(mode="numeric", length=len)
n_random <- as.numeric(rownames(equal_no_spots)[i])
counts_matrix_rand <- matrix(0, nrow = n, ncol = (length(breaks)-1))
for (k in 1:n){
random_indices <- sort(sample(indices, size=n_random,
replace=FALSE, prob=P))
interm_eukl <- euk[random_indices,random_indices]
eukl_for_rand <- interm_eukl[lower.tri(interm_eukl, diag=FALSE)]
counts_matrix_rand[k,] <- hist(eukl_for_rand, breaks,
plot=FALSE)$counts
}
mean_counts <- colMeans(counts_matrix_rand)
# Element-wise difference between the distance distributions of
#  the random samples and the mean distribution.
diff_matr_rand <- matrix(0, nrow=n, ncol=(length(breaks)-1))
diff_matr_rand <- t(apply(counts_matrix_rand,1,'-',mean_counts))
# The absolute values of these differences are summed over each row,
#  yielding the L1 norms for the distances between each random
#  distribution and the mean distribution.
abs_diff_rand <- abs(diff_matr_rand)
L1_norms_rand <- rowSums(abs_diff_rand)
# The true distributions.
eukl <- vector(mode="numeric", length=len)
vals <- vector(mode="numeric",
length=as.numeric(rownames(equal_no_spots)[i]) )
for (j in 1:nrow(values)){
vals <- which(values[j,]!=0)
eukli <- euk[vals,vals]
eukl <- eukli[lower.tri(eukli, diag=FALSE)]
eukdistr <- hist(eukl, breaks, plot=FALSE)
diff_real <- eukdistr$counts - mean_counts
abs_diff_real <- abs(diff_real)
L1_norm_real <- sum(abs_diff_real)
over_L1 <- L1_norms_rand[which(L1_norms_rand>=L1_norm_real)]
# Calculation of p values.
if (length(over_L1)!=0){
p[rownames(values)[j],1] <- length(over_L1)/n
} else {
p[rownames(values)[j],1] <- 1/(10*n)
}
}
}
diff_expr <- rownames(testdata[which(p<0.005),])
print(Sys.time() - start_time)
hist(non_zero[diff_expr,1], 0:(max(non_zero[diff_expr,1])+1))
p2 <- p[order(p$p_value), , drop = FALSE]
View(p)
p2 <- p[order(p$p), , drop = FALSE]
View(p2)
count <- nrow(p2)
alpha <- 0.05
test <- p2
for (i in 1:count){
test[i,1] <- p2[i,1]>(alpha/(count+1-i))
}
k <- min(which(test[,1]==TRUE))
diff_expr <- p2[1:(k-1),]
diff_expr <- rownames(testdata[which(p<0.005),])
diff_expr_MHT <- p2[1:(k-1),]
View(test)
alpha <- 0.05
test <- p2
for (i in 1:count){
test[i,1] <- (p2[i,1]>(alpha/(count+1-i)))
}
View(test)
p2[1,1]>(alpha/(count+1-1))
test <- matrix(NA, nrow=nrow(p2),ncol=1)
rownames(test)<- rownames(p2)
View(test)
for (i in 1:count){
test[i,1] <- (p2[i,1]>(alpha/(count+1-i)))
}
View(test)
k <- min(which(test[,1]==TRUE))
k <- min(which(test[,1]==TRUE))
if (k==1){
print("No null hypothesis can be rejected")
} else{
diff_expr_MHT <- p2[1:(k-1),]
}
View(p)
gene <- "Gnai3"
col <- as.numeric(as.vector(testdata[which(rownames(testdata)==gene),]))
# Create a colour gradient
rbPal <- colorRampPalette(c('yellow','red'))
color_vector <- rbPal(10)[as.numeric(cut(col,breaks = 10))]
xcoords <- as.numeric(sapply(strsplit(colnames(data), "x"), "[[", 1))
ycoords <- as.numeric(sapply(strsplit(colnames(data), "x"), "[[", 2))
# Plot the spot array with colours according to the gradient.
plot(x=xcoords, y=ycoords, col=alpha(color_vector, 1), lwd=1, asp=1,
ylab="", xlab="", main=paste(gene), pch=19, cex.main=1.5,
xaxt="n", yaxt="n", bty="n", col.main="black")
gene <- "Wnt3"
col <- as.numeric(as.vector(testdata[which(rownames(testdata)==gene),]))
# Create a colour gradient
rbPal <- colorRampPalette(c('yellow','red'))
color_vector <- rbPal(10)[as.numeric(cut(col,breaks = 10))]
xcoords <- as.numeric(sapply(strsplit(colnames(data), "x"), "[[", 1))
ycoords <- as.numeric(sapply(strsplit(colnames(data), "x"), "[[", 2))
# Plot the spot array with colours according to the gradient.
plot(x=xcoords, y=ycoords, col=alpha(color_vector, 1), lwd=1, asp=1,
ylab="", xlab="", main=paste(gene), pch=19, cex.main=1.5,
xaxt="n", yaxt="n", bty="n", col.main="black")
gene <- "Gabra2"
col <- as.numeric(as.vector(testdata[which(rownames(testdata)==gene),]))
# Create a colour gradient
rbPal <- colorRampPalette(c('yellow','red'))
color_vector <- rbPal(10)[as.numeric(cut(col,breaks = 10))]
xcoords <- as.numeric(sapply(strsplit(colnames(data), "x"), "[[", 1))
ycoords <- as.numeric(sapply(strsplit(colnames(data), "x"), "[[", 2))
# Plot the spot array with colours according to the gradient.
plot(x=xcoords, y=ycoords, col=alpha(color_vector, 1), lwd=1, asp=1,
ylab="", xlab="", main=paste(gene), pch=19, cex.main=1.5,
xaxt="n", yaxt="n", bty="n", col.main="black")
gene <- "Zfp385a"
col <- as.numeric(as.vector(testdata[which(rownames(testdata)==gene),]))
# Create a colour gradient
rbPal <- colorRampPalette(c('yellow','red'))
color_vector <- rbPal(10)[as.numeric(cut(col,breaks = 10))]
xcoords <- as.numeric(sapply(strsplit(colnames(data), "x"), "[[", 1))
ycoords <- as.numeric(sapply(strsplit(colnames(data), "x"), "[[", 2))
# Plot the spot array with colours according to the gradient.
plot(x=xcoords, y=ycoords, col=alpha(color_vector, 1), lwd=1, asp=1,
ylab="", xlab="", main=paste(gene), pch=19, cex.main=1.5,
xaxt="n", yaxt="n", bty="n", col.main="black")
gene <- "Kat2b"
col <- as.numeric(as.vector(testdata[which(rownames(testdata)==gene),]))
# Create a colour gradient
rbPal <- colorRampPalette(c('yellow','red'))
color_vector <- rbPal(10)[as.numeric(cut(col,breaks = 10))]
xcoords <- as.numeric(sapply(strsplit(colnames(data), "x"), "[[", 1))
ycoords <- as.numeric(sapply(strsplit(colnames(data), "x"), "[[", 2))
# Plot the spot array with colours according to the gradient.
plot(x=xcoords, y=ycoords, col=alpha(color_vector, 1), lwd=1, asp=1,
ylab="", xlab="", main=paste(gene), pch=19, cex.main=1.5,
xaxt="n", yaxt="n", bty="n", col.main="black")
View(p)
p2 <- p[order(p$p), , drop = FALSE]
View(p2)
count <- nrow(p2)
alpha <- 0.05
test <- matrix(NA, nrow=nrow(p2),ncol=1)
rownames(test)<- rownames(p2)
for (i in 1:count){
test[i,1] <- (p2[i,1]<=((i/count)*alpha))
}
k <- max(which(test[,1]==TRUE))
if (k==0){
print("No null hypothesis can be rejected")
} else{
diff_expr_MHT <- p2[1:k,]
}
View(p2)
diff_expr_MHT <- rownames(p2[1:k,1])
if (k==0){
print("No null hypothesis can be rejected")
} else{
diff_expr_MHT <- rownames(p2[1:k,1])
}
diff_expr_MHT <- rownames(p2[1:k,])
rownames(p2)
diff_expr_MHT <- rownames(p2)[1:k]
which(diff_expr==diff_expr_MHT)
p2 <- p[order(p$p), , drop = FALSE]
count <- nrow(p2)
alpha <- 0.005
test <- matrix(NA, nrow=nrow(p2),ncol=1)
rownames(test)<- rownames(p2)
for (i in 1:count){
test[i,1] <- (p2[i,1]<=((i/count)*alpha))
}
k <- max(which(test[,1]==TRUE))
if (k==0){
print("No null hypothesis can be rejected")
} else{
diff_expr_MHT <- rownames(p2)[1:k]
}
c <- 0
for (j in 1:count){
c <- c + 1/j
}
p2 <- p[order(p$p), , drop = FALSE]
count <- nrow(p2)
alpha <- 0.05
test <- matrix(NA, nrow=nrow(p2),ncol=1)
rownames(test)<- rownames(p2)
c <- 0
for (j in 1:count){
c <- c + 1/j
}
for (i in 1:count){
test[i,1] <- (p2[i,1]<=((i/(count*c))*alpha))
}
k <- max(which(test[,1]==TRUE))
if (k==0){
print("No null hypothesis can be rejected")
} else{
diff_expr_MHT <- rownames(p2)[1:k]
}
p2 <- p[order(p$p), , drop = FALSE]
count <- nrow(p2)
alpha <- 0.005
test <- matrix(NA, nrow=nrow(p2),ncol=1)
rownames(test)<- rownames(p2)
c <- 0
for (j in 1:count){
c <- c + 1/j
}
for (i in 1:count){
test[i,1] <- (p2[i,1]<=((i/(count*c))*alpha))
}
k <- max(which(test[,1]==TRUE))
if (k==0){
print("No null hypothesis can be rejected")
} else{
diff_expr_MHT <- rownames(p2)[1:k]
}
p2 <- p[order(p$p), , drop = FALSE]
count <- nrow(p2)
alpha <- 0.05
test <- matrix(NA, nrow=nrow(p2),ncol=1)
rownames(test)<- rownames(p2)
c <- 0
for (j in 1:count){
c <- c + 1/j
}
for (i in 1:count){
test[i,1] <- (p2[i,1]<=((i/(count*c))*alpha))
}
View(test)
k <- max(which(test[,1]==TRUE))
test[1000,1]
View(test)
p[280:281,1]
p2[280:281,1]
p2[280:283,]
p2 <- p[order(p$p), , drop = FALSE]
View(p2)
p2 <- p[order(p$p), , drop = FALSE]
count <- nrow(p2)
alpha <- 0.05
test <- matrix(NA, nrow=nrow(p2),ncol=1)
rownames(test)<- rownames(p2)
for (i in 1:count){
test[i,1] <- (p2[i,1]<=((i/count)*alpha))
}
k <- max(which(test[,1]==TRUE))
if (k==0){
print("No null hypothesis can be rejected")
} else{
diff_expr_MHT <- rownames(p2)[1:k]
}
x <- 1000/13882
x*0.05
x*0.005
p2 <- p[order(p$p), , drop = FALSE]
count <- nrow(p2)
alpha <- 0.005
test <- matrix(NA, nrow=nrow(p2),ncol=1)
rownames(test)<- rownames(p2)
for (i in 1:count){
# For the cases of which only p<0.001 (saved as p=0.0001) can be said
#  the procedure is only meaningful if these cases aren't the only
#  ones that pass the test
if (p2[i,1==0.0001]){
test[i,1] <- NA
} else{
test[i,1] <- (p2[i,1]<=((i/count)*alpha))
}
}
for (i in 1:count){
# For the cases of which only p<0.001 (saved as p=0.0001) can be said
#  the procedure is only meaningful if these cases aren't the only
#  ones that pass the test
if (p2[i,1]==0.0001){
test[i,1] <- NA
} else{
test[i,1] <- (p2[i,1]<=((i/count)*alpha))
}
}
k <- max(which(test[,1]==TRUE))
for (i in 1:count){
# For the cases of which only p<0.001 (saved as p=0.0001) can be said
#  the procedure is only meaningful if these cases aren't the only
#  ones that pass the test
if (p2[i,1]==0.0001){
test[i,1] <- FALSE
} else{
test[i,1] <- (p2[i,1]<=((i/count)*alpha))
}
}
k <- max(which(test[,1]==TRUE))
alpha <- 0.05
test <- matrix(NA, nrow=nrow(p2),ncol=1)
rownames(test)<- rownames(p2)
for (i in 1:count){
# For the cases of which only p<0.001 (saved as p=0.0001) can be said
#  the procedure is only meaningful if these cases aren't the only
#  ones that pass the test
if (p2[i,1]==0.0001){
test[i,1] <- FALSE
} else{
test[i,1] <- (p2[i,1]<=((i/count)*alpha))
}
}
k <- max(which(test[,1]==TRUE))
if (k==0){
print("No null hypothesis can be rejected")
} else{
diff_expr_MHT <- rownames(p2)[1:k]
}
alpha <- 0.005
test <- matrix(NA, nrow=nrow(p2),ncol=1)
rownames(test)<- rownames(p2)
for (i in 1:count){
# For the cases of which only p<0.001 (saved as p=0.0001) can be said
#  the procedure is only meaningful if these cases aren't the only
#  ones that pass the test
if (p2[i,1]==0.0001){
test[i,1] <- FALSE
} else{
test[i,1] <- (p2[i,1]<=((i/count)*alpha))
}
}
k <- max(which(test[,1]==TRUE))
View(test)
k <- max(which(test[,1]==TRUE))
if (k==-Inf){
print("No null hypothesis can be rejected")
} else{
diff_expr_MHT <- rownames(p2)[1:k]
}
?suppressWarnings
suppressWarnings(k <- max(which(test[,1]==TRUE)))
k<-1
p2 <- p[order(p$p), , drop = FALSE]
count <- nrow(p2)
alpha <- 0.005
test <- matrix(NA, nrow=nrow(p2),ncol=1)
rownames(test)<- rownames(p2)
for (i in 1:count){
# For the cases of which only p<0.001 (saved as p=0.0001) can be said
#  the procedure is only meaningful if these cases aren't the only
#  ones that pass the test
if (p2[i,1]==0.0001){
test[i,1] <- FALSE
} else{
test[i,1] <- (p2[i,1]<=((i/count)*alpha))
}
}
suppressWarnings(k <- max(which(test[,1]==TRUE)))
if (k==-Inf){
print("No null hypothesis can be rejected")
} else{
diff_expr_MHT <- rownames(p2)[1:k]
}
alpha <- 0.01
test <- matrix(NA, nrow=nrow(p2),ncol=1)
rownames(test)<- rownames(p2)
for (i in 1:count){
# For the cases of which only p<0.001 (saved as p=0.0001) can be said
#  the procedure is only meaningful if these cases aren't the only
#  ones that pass the test
if (p2[i,1]==0.0001){
test[i,1] <- FALSE
} else{
test[i,1] <- (p2[i,1]<=((i/count)*alpha))
}
}
suppressWarnings(k <- max(which(test[,1]==TRUE)))
if (k==-Inf){
print("No null hypothesis can be rejected")
} else{
diff_expr_MHT <- rownames(p2)[1:k]
}
alpha <- 0.02
test <- matrix(NA, nrow=nrow(p2),ncol=1)
rownames(test)<- rownames(p2)
for (i in 1:count){
# For the cases of which only p<0.001 (saved as p=0.0001) can be said
#  the procedure is only meaningful if these cases aren't the only
#  ones that pass the test
if (p2[i,1]==0.0001){
test[i,1] <- FALSE
} else{
test[i,1] <- (p2[i,1]<=((i/count)*alpha))
}
}
suppressWarnings(k <- max(which(test[,1]==TRUE)))
if (k==-Inf){
print("No null hypothesis can be rejected")
} else{
diff_expr_MHT <- rownames(p2)[1:k]
}
for (val in which(p2[,1]==0.0001)){
p2[val,1]<-0.001
}
View(p2)
p2 <- p[order(p$p), , drop = FALSE]
count <- nrow(p2)
alpha <- 0.05
test <- matrix(NA, nrow=nrow(p2),ncol=1)
rownames(test)<- rownames(p2)
for (val in which(p2[,1]==0.0001)){
p2[val,1]<-0.001
}
for (i in 1:count){
# For the cases of which only p<0.001 (saved as p=0.0001) can be said
#  the procedure is only meaningful if these cases aren't the only
#  ones that pass the test
#if (p2[i,1]==0.0001){
#  test[i,1] <- FALSE
#} else{
test[i,1] <- (p2[i,1]<=((i/count)*alpha))
#}
}
suppressWarnings(k <- max(which(test[,1]==TRUE)))
if (k==-Inf){
print("No null hypothesis can be rejected with certainty")
} else{
diff_expr_MHT <- rownames(p2)[1:k]
}
alpha <- 0.02
test <- matrix(NA, nrow=nrow(p2),ncol=1)
rownames(test)<- rownames(p2)
for (val in which(p2[,1]==0.0001)){
p2[val,1]<-0.001
}
for (i in 1:count){
# For the cases of which only p<0.001 (saved as p=0.0001) can be said
#  the procedure is only meaningful if these cases aren't the only
#  ones that pass the test
#if (p2[i,1]==0.0001){
#  test[i,1] <- FALSE
#} else{
test[i,1] <- (p2[i,1]<=((i/count)*alpha))
#}
}
suppressWarnings(k <- max(which(test[,1]==TRUE)))
if (k==-Inf){
print("No null hypothesis can be rejected with certainty")
} else{
diff_expr_MHT <- rownames(p2)[1:k]
}
p2 <- p[order(p$p), , drop = FALSE]
count <- nrow(p2)
alpha <- 0.05
test <- matrix(NA, nrow=nrow(p2),ncol=1)
rownames(test)<- rownames(p2)
# For the cases of which only p<0.001 (saved as p=0.0001) can be said
#  the procedure is only meaningful if these cases aren't the only
#  ones that pass the test. Since it is however certain that they
#  have p-values of less than 0.001, the below will never lead to any
#  conclusions of null hypothesis rejection if this cannot certainly
#  be supported.
for (val in which(p2[,1]==0.0001)){
p2[val,1]<-0.001
}
c <- 0
for (j in 1:count){
c <- c + 1/j
}
for (i in 1:count){
test[i,1] <- (p2[i,1]<=((i/(count*c))*alpha))
}
k <- max(which(test[,1]==TRUE))
suppressWarnings(k <- max(which(test[,1]==TRUE)))
if (k==-Inf){
print("No null hypothesis can be rejected")
} else{
diff_expr_MHT <- rownames(p2)[1:k]
}
